% =========================================================================
% RSGA (Rough Surface Generator & Analyzer)
%
% A modular MATLAB tool for the creation and characterization of 2D random
% rough surfaces.
%
%                                                                 v. 5.0.0
%                                                     Created : 04/08/2015
%                                                     Updated : 04/10/2025
% -------------------------------------------------------------------------
%                                                           Soheil Solhjoo
%                                                  University of Groningen
% =========================================================================
clc; clear; close all;

% --- Add project subfolders to the MATLAB path ---
% This ensures that functions in folders like /utils and /+models are found.
addpath(genpath(pwd));

config = struct(); % Initialize config structure
%% =========================================================================
% --- 0. MASTER WORKFLOW CONTROL ---
% =========================================================================
% 'Generate and Analyze': Creates a new surface from scratch, analyzes, and saves it.
% 'Analyze Only': Loads an existing .mat file and runs the analysis on it.
config.workflow.mode = 'Generate and Analyze';
% config.workflow.mode = 'Analyze Only';
overwrite_config = true;

% If in 'Analyze Only' mode, specify the file to load.
config.workflow.loadFile = 'outSurf.mat'; % Example filename

% Specify variable names IF loading a simple .mat file.
% If loading a full session file generated by this tool, these are ignored.
% Modify these strings to match the variable names in your simple .mat file.
config.workflow.loadSimpleFile.varNames.x = 'x'; % Name of the 1D x-coordinate vector
config.workflow.loadSimpleFile.varNames.y = 'y'; % Name of the 1D y-coordinate vector
config.workflow.loadSimpleFile.varNames.f = 'f'; % Name of the 2D height matrix
%% =========================================================================
% --- 1. Grid and Anisotropy Settings ---
% =========================================================================
% Let's keep it isotropic!
config.grid.is_anisotropic = false;         % Master switch for anisotropic generation

Nxy = 100;
dxy = 1;
config.grid.num_points = [Nxy, Nxy];        % Number of points [Nx, Ny]
config.grid.point_spacing = [dxy, dxy];     % Distance between points [dx, dy]
%% =========================================================================
% --- 2. Generation Method Selection ---
% =========================================================================
% 'PSD': Standard Fourier method defining the Power Spectral Density (PSD).
% 'ACF': Standard Fourier method defining the Autocovariance Function (ACF).
% config.generation.method = 'ACF';
config.generation.method = 'PSD_FFT';
% config.generation.method = 'PSD_SUM';

%% =========================================================================
% --- 3. Method-Specific Parameters ---
% =========================================================================

% --- A) PSD Method Configuration ---
if startsWith(config.generation.method, 'PSD')
    config.psd.model = @psd_models.simple_rolloff;
    % config.psd.model = @psd_models.k_correlation;

    model_name = func2str(config.psd.model);
    if contains(model_name, 'simple_rolloff')
        % Parameters for the Simple Rolloff model
        % Constraint Mode determines how the PSD amplitude is calculated.
        % 'm0': Match a target RMS height (m0).
        % 'm2': Match a target RMS gradient (m2).
        % 'm0_and_m2': Match BOTH (requires a model with a free parameter like simple_rolloff).
        config.psd.constraint_mode = 'm0';
    elseif contains(model_name, 'k_correlation')
        % Parameters for the K-correlation (Palasantzas) model
        config.psd.model = @psd_models.k_correlation;
        config.psd.constraint_mode = 'm0';
    end
    config.psd.target_rms_height = 8.0;
    config.psd.target_rms_gradient = 1;
    config.psd.psd_slope = -8;
    config.psd.corr_lengths = 20;% Use scalar since the surface will be isotropic.

    % Amplitude Method (not implemented for PSD_SUM)
    % 'srm': Spectral Representation Method (deterministic, recommended).
    % 'fft_filter': Adds a random component to amplitudes.
    config.psd.amplitude_method = 'fft_filter';
end

% --- B) ACF Method Configuration ---
if strcmp(config.generation.method, 'ACF')
    % choose one of the following lines: exponential or gaussian
    % config.acf.model = @acf_models.exponential;
    config.acf.model = @acf_models.gaussian;

    config.acf.initial_noise_dist = @distributions.randn_noise;
    config.acf.target_rms_height = 8.0;

    % Correlation length(s). This parameter is dependent on config.grid.is_anisotropic.
    % - For ISOTROPIC (is_anisotropic = false): Provide a single scalar value. e.g., 40.0
    % - For ANISOTROPIC (is_anisotropic = true): Provide a 1x2 vector [cl_x, cl_y]. e.g., [40.0, 20.0]
    config.acf.corr_lengths = 20.0;
end
%% =========================================================================
% --- 4. Analysis, Plotting, and Output ---
% =========================================================================

% --- Analysis Switches ---
config.analysis.calculate_statistics = true;  % Skewness, Kurtosis
config.analysis.calculate_moments = true;     % m0, m2, m4
config.analysis.calculate_asperity_params = true; % Calculate GW-style asperity parameters
config.analysis.calculate_psd = true;         % Calculate PSD from the generated surface
config.analysis.calculate_acf = true;         % Calculate ACF and correlation lengths from the surface

% --- Plotting Switches ---
config.plotting.show_surface_3d = true;
config.plotting.show_psd_plot = true;
config.plotting.show_acf_plot = true;
config.plotting.show_height_histogram = true;

% --- Output Switches ---
config.output.save_mat = true;
config.output.save_summary_txt = true;   % Save the summary report to a .txt file
% config.output.save_xyz = true;
config.output.folder = 'output';
config.output.filename_prefix = 'MySurfaceRun';
%% ========================================================================
% --- 5. EXECUTION ---
% =========================================================================
if strcmpi(config.workflow.mode, 'Generate and Analyze')
    disp('*** Starting Workflow: GENERATE AND ANALYZE ***');

    % Step 1: Generate the surface
    surface_data = generate_surface(config);

    % Step 2: Analyze the generated surface
    analysis_results = analyze_surface(surface_data, config);

    % Step 3: Report the results
    report_results(surface_data, analysis_results, config);

    % Step 4: Save the entire session
    if config.output.save_mat
        save_session(config, surface_data, analysis_results);
    end
elseif strcmpi(config.workflow.mode, 'Analyze Only')
    disp('*** Starting Workflow: ANALYZE ONLY ***');

    % Step 1: Load a previously saved session
    % Note: load_session returns the config used to GENERATE the surface.
    [loaded_config, surface_data] = load_session(config.workflow.loadFile, config);

    % --- Create a robust config for reporting ---
    % This logic implements your suggestion to merge settings.
    if isempty(loaded_config)
        % If a simple file was loaded, the report should use the current
        % settings from this main_runner.m file.
        report_config = config;
    else
        % If a full session was loaded, start with the original config...
        report_config = loaded_config;
        if overwrite_config
            % ...but overwrite its analysis and plotting switches with the
            % current settings, allowing the user to override them.
            report_config.psd.model = config.psd.model;
            report_config.analysis = config.analysis;
            report_config.plotting = config.plotting;
        end
    end

    % Step 2: Analyze the loaded surface using the CURRENT config settings
    % This allows you to re-run analysis with different parameters.
    analysis_results = analyze_surface(surface_data, report_config);

    % Step 3: Report the new results
    % We pass the original config (loaded_config) to the reporter so it
    % can accurately compare generated values to their original targets.
    report_results(surface_data, analysis_results, report_config);

else
    error('Invalid workflow mode specified in config.workflow.mode');
end